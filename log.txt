Illiterate Vulkan!
App::initWindow {
  Creating window:  800 x 600  -  Vulkan
  glfwCreateWindow
}
App::initRenderer {
  glint::Renderer::Renderer {
  }
  glint::Renderer::init {
    glint::VulkanContext::VulkanContext {
    }
    glint::VulkanContext::init {
      glint::VulkanContext::createInstance {
        glint::VulkanContext::checkValidationLayerSupport {
          found validation layer:  VK_LAYER_KHRONOS_validation
        }
        glint::VulkanContext::getRequiredExtensions {
          Required Extensions:  3
             VK_KHR_surface
             VK_KHR_win32_surface
             VK_EXT_debug_utils
        }
        validation layers are enabled
        glint::VulkanContext::populateDebugMessengerCreateInfo {
        }
        vkCreateInstance(&createInfo, nullptr, &m_Instance)
      }
      glint::VulkanContext::setupDebugMessenger {
        glint::VulkanContext::populateDebugMessengerCreateInfo {
        }
        glint::CreateDebugUtilsMessengerEXT {
        }
      }
      glint::VulkanContext::createSurface {
        glint::Window::createSurface {
          VkResult result = glfwCreateWindowSurface(instance, m_Window, nullptr, &surface)
        }
      }
      glint::VulkanContext::pickPhysicalDevice {
        Available Devices:  2
        glint::VulkanContext::isDeviceSuitable {
          glint::VulkanContext::findQueueFamilies {
          }
          glint::VulkanContext::checkDeviceExtensionSupport {
          }
        }
        found suitable device  NVIDIA GeForce RTX 3060 Laptop GPU
      }
      glint::VulkanContext::createLogicalDevice {
        glint::VulkanContext::findQueueFamilies {
        }
        vkCreateDevice(m_PhysicalDevice, &createInfo, nullptr, &m_Device)
      }
    }
    glint::SwapChain::SwapChain {
      glint::SwapChain::createSwapChain {
        glint::SwapChain::querySwapChainSupport {
        }
        glint::SwapChain::chooseSwapSurfaceFormat {
        }
        glint::SwapChain::chooseSwapPresentMode {
          Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
        }
        glint::SwapChain::chooseSwapExtent {
        }
        graphics and present queues are the same
        Using exclusive sharing mode
      }
      glint::SwapChain::createImageViews {
      }
    }
    glint::RenderPass::RenderPass {
      glint::RenderPass::createRenderPass {
        clear the values to a constant at the start
        colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR
        store the values to memory for reading later
        colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE
        not using stencil buffer
        colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE
        colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
        layout transition before and after render pass
        colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
        colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
        which attachment to reference by its index in the attachment descriptions array
        colorAttachmentRef.attachment = 0
        layout the attachment will have during a subpass
        colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
        subpass dependencies, for layout transitions
        subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS
        subpass.colorAttachmentCount = 1
        subpass.pColorAttachments = &colorAttachmentRef
        dependency between the subpass and the external render pass
        dependency.srcSubpass = VK_SUBPASS_EXTERNAL
        dependency.dstSubpass = 0
        dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
        dependency.srcAccessMask = 0
        dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
        dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
        Render Pass
        VkRenderPassCreateInfo renderPassInfo{}
        vkCreateRenderPass(m_Context->getDevice(), &renderPassInfo, nullptr, &m_RenderPass)
      }
    }
    glint::Pipeline::Pipeline {
      glint::Pipeline::createGraphicsPipeline {
        Loading shaders, can either load pre-compiled shaders, or compile at runtime to SPIR-V
        glint::Pipeline::readFile {
          Loading filename: ./bin/shaders/shader.vert.spv fileSize: 1052 bytes
        }
        glint::Pipeline::readFile {
          Loading filename: ./bin/shaders/shader.frag.spv fileSize: 572 bytes
        }
        VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
        glint::Pipeline::createShaderModule {
        }
        VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
        glint::Pipeline::createShaderModule {
        }
        Vertex Input
        VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
        glint::Vertex::getBindingDescription {
        }
        glint::Vertex::getAttributeDescriptions {
          attributeDescriptions[0].offset = offsetof(Vertex, position)
          attributeDescriptions[1].offset = offsetof(Vertex, color)
        }
        Input Assembly
        VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
        Dynamic States - used for viewport and scissor
        Viewport State, dynamic states are used for viewport and scissor
        VkPipelineViewportStateCreateInfo viewportState{}
        Rasterizer
        VkPipelineRasterizationStateCreateInfo rasterizer{}
        Using anything else requires enabling GPU features.
        rasterizer.polygonMode = VK_POLYGON_MODE_FILL
        rasterizer.lineWidth = 1.0f
        rasterizer.depthBiasEnable = VK_FALSE
        Depth Bias, for shadow mapping.
        Multisampling, disabled for now.
        VkPipelineMultisampleStateCreateInfo multisampling{}
        Depth and Stencil testing, disabled for now, will pass on nullptr
        Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
        It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
        VkPipelineColorBlendAttachmentState colorBlendAttachment{}
        Global color blending settings
        VkPipelineColorBlendStateCreateInfo colorBlending{}
        Pipeline Layout
        uniform values, push constants, etc.
        VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
        vkCreatePipelineLayout(m_Context->getDevice(), &pipelineLayoutInfo, nullptr, &m_PipelineLayout)
        Create Graphics Pipeline
        Graphics Pipeline, the final pipeline object that will be used in rendering
        Here we are combining : shaders, fixed function stages(vertex info, input assembly, viewport syate, rasterizer, multisampleing, depthStencil and color blending), pipeline layout and render pass
        VkGraphicsPipelineCreateInfo pipelineInfo{}
        vkCreateGraphicsPipelines(m_Context->getDevice(), VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline)
        Cleanup shader modules
        vkDestroyShaderModule(m_Context->getDevice(), fragShaderModule, nullptr)
        vkDestroyShaderModule(m_Context->getDevice(), vertShaderModule, nullptr)
      }
    }
    glint::SwapChain::createFramebuffers {
    }
    glint::CommandManager::CommandManager {
      glint::CommandManager::createCommandPool {
        Choose graphics family as we are using the command buffer for rendering
      }
      glint::CommandManager::createCommandBuffers {
        Creating 2 command buffers
      }
    }
    glint::SynchronizationManager::SynchronizationManager {
      glint::SynchronizationManager::createSyncObjects {
        Synchronization:
        Semaphors: signal and wait for the image available and render finished, sync between queues
        Fences: wait for the frame to finish before starting the next one, sync between CPU and GPU
        Creating 2 sets of synchronization objects
        Create fence in signaled state, so that the first frame can start immediately
      }
    }
    Renderer initialized with 2 frames in flight and 3 swap chain images
  }
}
App::initMesh {
  glint::MeshFactory::createTriangle {
    glint::Mesh::Mesh {
      glint::Mesh::createVertexBuffer {
        glint::VulkanContext::createBuffer {
          vkCreateBuffer(m_Device, &bufferInfo, nullptr, &buffer)
          glint::VulkanContext::findMemoryType {
          }
          vkAllocateMemory(m_Device, &allocInfo, nullptr, &bufferMemory)
        }
        glint::VulkanContext::createBuffer {
          vkCreateBuffer(m_Device, &bufferInfo, nullptr, &buffer)
          glint::VulkanContext::findMemoryType {
          }
          vkAllocateMemory(m_Device, &allocInfo, nullptr, &bufferMemory)
        }
        glint::Mesh::copyBuffer {
          Command Buffer for Buffer Copy
          vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer)
          Begin Command Buffer
          vkBeginCommandBuffer(commandBuffer, &beginInfo)
          Copy Buffer
          vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion)
          End Command Buffer
          vkEndCommandBuffer(commandBuffer)
          Submit Command Buffer
          vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE)
          vkQueueWaitIdle(graphicsQueue)
          Free Command Buffer
          vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer)
        }
      }
      Mesh created with 3 vertices and 0 indices
    }
  }
}
App::mainLoop {
  while (!window->shouldClose())
  glint::Renderer::drawFrame {
    --------------------------------------------------------------
    Outline of a frame..
    Wait for the previous frame to be finished
    Acquire an image from the swap chain
    Record a command buffer which draws the scene onto the image.
    Submit the command buffer to the graphics queue.
    Present the image to the swap chain for presentation.
    --------------------------------------------------------------
    glint::SynchronizationManager::waitForFence {
      Wait for the previous frame to be finished
    }
    glint::CommandManager::resetCommandBuffer {
    }
    glint::CommandManager::beginSingleTimeCommands {
    }
    App::drawScene {
      glint::RenderPass::begin {
        Start Render Pass
        VkRenderPassBeginInfo renderPassInfo{}
        vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE)
      }
      glint::Pipeline::bind {
        Bind Pipeline
        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_Pipeline)
      }
      glint::Mesh::bind {
      }
      Set dynamic states
      vkCmdSetScissor(commandBuffer, 0, 1, &scissor)
      FINALLY DRAW!!!
      glint::Mesh::draw {
      }
      glint::RenderPass::end {
        End Render Pass
        vkCmdEndRenderPass(commandBuffer)
      }
    }
    glint::CommandManager::endSingleTimeCommands {
    }
    glint::SynchronizationManager::resetFence {
    }
    result = vkQueuePresentKHR(m_Context->getPresentQueue(), &presentInfo)
  }
  glint::Renderer::waitIdle {
  }
}
App::cleanup {
}
glint::Mesh::~Mesh {
  vkDestroyBuffer(device, m_VertexBuffer, nullptr)
  vkFreeMemory(device, m_VertexBufferMemory, nullptr)
}
glint::Renderer::~Renderer {
}
glint::SynchronizationManager::~SynchronizationManager {
}
glint::CommandManager::~CommandManager {
}
glint::Pipeline::~Pipeline {
  vkDestroyPipeline(device, m_Pipeline, nullptr)
  vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr)
}
glint::RenderPass::~RenderPass {
  vkDestroyRenderPass(m_Context->getDevice(), m_RenderPass, nullptr)
}
glint::SwapChain::~SwapChain {
  glint::SwapChain::cleanup {
    Destroying  3  framebuffers
    Destroying  3  image views
    vkDestroySwapchainKHR(device, m_SwapChain, nullptr)
  }
}
glint::VulkanContext::~VulkanContext {
  glint::VulkanContext::cleanup {
    glint::DestroyDebugUtilsMessengerEXT {
    }
  }
}
glint::Window::~Window {
  glint::Window::shutdown {
    glfwDestroyWindow(m_Window)
    glfwTerminate()
  }
}
