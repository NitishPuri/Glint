Illiterate Vulkan!
App::initWindow {
  Creating window:  800 x 600  -  Vulkan
  glfwCreateWindow
}
App::initVulkan {
  glint::VulkanContext::VulkanContext {
  }
  glint::VulkanContext::init {
    glint::VulkanContext::createInstance {
      glint::VulkanContext::checkValidationLayerSupport {
        found validation layer:  VK_LAYER_KHRONOS_validation
      }
      glint::VulkanContext::getRequiredExtensions {
        Required Extensions:  3
           VK_KHR_surface
           VK_KHR_win32_surface
           VK_EXT_debug_utils
      }
      validation layers are enabled
      glint::VulkanContext::populateDebugMessengerCreateInfo {
      }
      vkCreateInstance(&createInfo, nullptr, &m_Instance)
    }
    glint::VulkanContext::setupDebugMessenger {
      glint::VulkanContext::populateDebugMessengerCreateInfo {
      }
      glint::CreateDebugUtilsMessengerEXT {
      }
    }
    glint::VulkanContext::createSurface {
      glint::Window::createSurface {
        VkResult result = glfwCreateWindowSurface(instance, m_Window, nullptr, &surface)
      }
    }
    glint::VulkanContext::pickPhysicalDevice {
      Available Devices:  2
      glint::VulkanContext::isDeviceSuitable {
        glint::VulkanContext::findQueueFamilies {
        }
        glint::VulkanContext::checkDeviceExtensionSupport {
        }
      }
      found suitable device  NVIDIA GeForce RTX 3060 Laptop GPU
    }
    glint::VulkanContext::createLogicalDevice {
      glint::VulkanContext::findQueueFamilies {
      }
      vkCreateDevice(m_PhysicalDevice, &createInfo, nullptr, &m_Device)
    }
  }
  glint::SwapChain::SwapChain {
    glint::SwapChain::createSwapChain {
      glint::SwapChain::querySwapChainSupport {
      }
      glint::SwapChain::chooseSwapSurfaceFormat {
      }
      glint::SwapChain::chooseSwapPresentMode {
        Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
      }
      glint::SwapChain::chooseSwapExtent {
      }
      graphics and present queues are the same
      Using exclusive sharing mode
    }
    glint::SwapChain::createImageViews {
    }
  }
  glint::RenderPass::RenderPass {
    glint::RenderPass::createRenderPass {
      clear the values to a constant at the start
      colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR
      store the values to memory for reading later
      colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE
      not using stencil buffer
      colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE
      colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
      layout transition before and after render pass
      colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
      colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
      which attachment to reference by its index in the attachment descriptions array
      colorAttachmentRef.attachment = 0
      layout the attachment will have during a subpass
      colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
      subpass dependencies, for layout transitions
      subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS
      subpass.colorAttachmentCount = 1
      subpass.pColorAttachments = &colorAttachmentRef
      dependency between the subpass and the external render pass
      dependency.srcSubpass = VK_SUBPASS_EXTERNAL
      dependency.dstSubpass = 0
      dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
      dependency.srcAccessMask = 0
      dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
      dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
      Render Pass
      VkRenderPassCreateInfo renderPassInfo{}
      vkCreateRenderPass(m_Context->getDevice(), &renderPassInfo, nullptr, &m_RenderPass)
    }
  }
  App::createGraphicsPipeline {
    Loading shaders, can wither load pre compiled shaders, or compile at runtime to SPIR-V
    readFile {
      Loading filename: ./bin/shaders/shader.vert.spv fileSize: 1504 bytes
    }
    readFile {
      Loading filename: ./bin/shaders/shader.frag.spv fileSize: 572 bytes
    }
    VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
    App::createShaderModule {
      vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule)
    }
    VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
    App::createShaderModule {
      vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule)
    }
    Vertex Input
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
    Input Assembly
    VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
    Viewport State, dynamic states are used for viewport and scissor
    VkPipelineViewportStateCreateInfo viewportState{}
    Rasterizer
    VkPipelineRasterizationStateCreateInfo rasterizer{}
    Using anything else requires enabling GPU features.
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL
    rasterizer.lineWidth = 1.0f
    rasterizer.depthBiasEnable = VK_FALSE
    Depth Bias, for shadow mapping.
    Multisampling, disabled for now.
    VkPipelineMultisampleStateCreateInfo multisampling{}
    Depth and Stencil testing, disabled for now, will pass on nullptr
    Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
    It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
    VkPipelineColorBlendAttachmentState colorBlendAttachment{}
    VkPipelineColorBlendStateCreateInfo colorBlending{}
    Setup dynamic states
    Pipeline Layout, for uniforms and push constants
    VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
    vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout)
    Create Graphics Pipeline
    Graphics Pipeline, the final pipeline object that will be used in rendering
    Here we are combining : shaders, fixed function stages(vertex info, input assembly, viewport syate, rasterizer, multisampleing, depthStencil and color blending), pipeline layout and render pass
    VkGraphicsPipelineCreateInfo pipelineInfo{}
    vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline)
    vkDestroyShaderModule(device, vertShaderModule, nullptr)
    vkDestroyShaderModule(device, fragShaderModule, nullptr)
  }
  glint::SwapChain::createFramebuffers {
  }
  App::createCommandPool {
    VkCommandPoolCreateInfo poolInfo{}
    Choose graphics family as we are using the command buffer for rendering
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value()
    vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool)
  }
  App::createCommandBuffer {
    VkCommandBufferAllocateInfo allocInfo{}
    vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer)
  }
  App::createSyncObjects {
    Synchronization:
    Semaphors: signal and wait for the image available and render finished, sync between queues
    Fences: wait for the frame to finish before starting the next one, sync between CPU and GPU
    Create fence in signaled state, so that the first frame can start immediately
    vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore)
    vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore)
    vkCreateFence(device, &fenceInfo, nullptr, &inFlightFence)
  }
}
App::mainLoop {
  while (!window->shouldClose())
  App::drawFrame {
    --------------------------------------------------------------
    Outline of a frame..
    Wait for the previous frame to be finished
    Acquire an image from the swap chain
    Record a command buffer which draws the scene onto the image.
    Submit the command buffer to the graphics queue.
    Present the image to the swap chain for presentation.
    --------------------------------------------------------------
    Wait for the previous frame to be finished
    vkWaitForFences(device, 1, &inFlightFence, VK_TRUE, UINT64_MAX)
    vkResetFences(device, 1, &inFlightFence)
    Acquire an image from the swap chain
    vkAcquireNextImageKHR(device, swapChain->getSwapChain(), UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex)
    vkResetCommandBuffer(commandBuffer, 0)
    Record a command buffer which draws the scene onto the image.
    App::recordCommandBuffer {
      vkBeginCommandBuffer(commandBuffer, &beginInfo)
      glint::RenderPass::begin {
        Start Render Pass
        VkRenderPassBeginInfo renderPassInfo{}
        vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE)
      }
      Bind Pipeline
      vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline)
      Set dynamic states
      vkCmdSetViewport(commandBuffer, 0, 1, &viewport)
      vkCmdSetScissor(commandBuffer, 0, 1, &scissor)
      FINALLY DRAW!!!
      vkCmdDraw(commandBuffer, 3, 1, 0, 0)
      glint::RenderPass::end {
        End Render Pass
        vkCmdEndRenderPass(commandBuffer)
      }
      vkEndCommandBuffer(commandBuffer)
      Command Buffer Recorded
    }
    Wait for the imageAvailableSemaphore..
    Wait till the color attachment is ready for writing..
    Submit the command buffer to the graphics queue
    vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFence)
    Presentation
    Wait for the renderFinishedSemaphore..
    Specify swap chain to present to.
    Present the image to the swap chain for presentation.
    vkQueuePresentKHR(presentQueue, &presentInfo)
  }
  vkDeviceWaitIdle(device)
}
App::cleanup {
  vkDestroySemaphore(device, renderFinishedSemaphore, nullptr)
  vkDestroySemaphore(device, imageAvailableSemaphore, nullptr)
  vkDestroyFence(device, inFlightFence, nullptr)
  vkDestroyCommandPool(device, commandPool, nullptr)
  vkDestroyPipeline(device, graphicsPipeline, nullptr)
  vkDestroyPipelineLayout(device, pipelineLayout, nullptr)
  glint::RenderPass::~RenderPass {
  }
  glint::SwapChain::~SwapChain {
  }
  glint::VulkanContext::~VulkanContext {
    glint::VulkanContext::cleanup {
      glint::DestroyDebugUtilsMessengerEXT {
      }
    }
  }
  glint::Window::~Window {
    glint::Window::shutdown {
      glfwDestroyWindow(m_Window)
      glfwTerminate()
    }
  }
}
