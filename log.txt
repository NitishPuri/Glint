Creating window:  800 x 600  -  Glint - Triangle
glfwCreateWindow
glint::Renderer::Renderer {
}
glint::Renderer::init {
  glint::VkContext::VkContext {
  }
  glint::VkContext::init {
    glint::VkContext::createInstance {
      glint::VkContext::checkValidationLayerSupport {
        found validation layer:  VK_LAYER_KHRONOS_validation
      }
      glint::VkContext::getRequiredExtensions {
        Required Extensions:  3
           VK_KHR_surface
           VK_KHR_win32_surface
           VK_EXT_debug_utils
      }
      validation layers are enabled
      glint::VkContext::populateDebugMessengerCreateInfo {
      }
      vkCreateInstance(&createInfo, nullptr, &m_Instance)
    }
    glint::VkContext::setupDebugMessenger {
      glint::VkContext::populateDebugMessengerCreateInfo {
      }
      glint::CreateDebugUtilsMessengerEXT {
      }
    }
    glint::VkContext::createSurface {
      glint::Window::createSurface {
        VkResult result = glfwCreateWindowSurface(instance, m_Window, nullptr, &surface)
      }
    }
    glint::VkContext::pickPhysicalDevice {
      Available Devices:  2
      glint::VkContext::isDeviceSuitable {
        glint::VkContext::findQueueFamilies {
        }
        glint::VkContext::checkDeviceExtensionSupport {
        }
      }
      found suitable device  NVIDIA GeForce RTX 3060 Laptop GPU
      Max Usable Sample Count:  8
    }
    glint::VkContext::createLogicalDevice {
      glint::VkContext::findQueueFamilies {
      }
      vkCreateDevice(m_PhysicalDevice, &createInfo, nullptr, &m_Device)
    }
  }
  glint::CommandManager::CommandManager {
    glint::CommandManager::createCommandPool {
      Choose graphics family as we are using the command buffer for rendering
    }
    glint::CommandManager::createCommandBuffers {
      Creating 2 command buffers
    }
  }
  glint::SwapChain::SwapChain {
    glint::SwapChain::createSwapChain {
      glint::SwapChain::querySwapChainSupport {
      }
      glint::SwapChain::chooseSwapSurfaceFormat {
      }
      glint::SwapChain::chooseSwapPresentMode {
        Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
      }
      glint::SwapChain::chooseSwapExtent {
      }
      graphics and present queues are the same
      Using exclusive sharing mode
    }
    glint::SwapChain::createImageViews {
    }
    glint::SwapChain::createDepthResources {
      Set debug name for 10 to Depth Image
      Set debug name for 8 to Depth Image Memory
      Set debug name for 14 to Depth Image View
      glint::VkUtils::transitionImageLayout {
      }
    }
  }
  glint::RenderPass::RenderPass {
    glint::RenderPass::createRenderPass {
      vkCreateRenderPass(m_Context->getDevice(), &renderPassInfo, nullptr, &m_RenderPass)
    }
  }
  glint::SwapChain::createFramebuffers {
  }
  glint::SynchronizationManager::SynchronizationManager {
    glint::SynchronizationManager::createSyncObjects {
      Synchronization:
      Semaphors: signal and wait for the image available and render finished, sync between queues
      Fences: wait for the frame to finish before starting the next one, sync between CPU and GPU
      Creating 2 sets of synchronization objects
      Create fence in signaled state, so that the first frame can start immediately
    }
  }
  Renderer initialized with 2 frames in flight and 3 swap chain images
}
glint::Texture::Texture {
  glint::Texture::createTextureImage {
    Loading texture from ./res/texture.jpg
    Texture loaded: 512 x 512 pixels, 3 channels
    Set debug name for 9 to Texture Staging Buffer
    Set debug name for 8 to Texture Staging Buffer Memory
    Set debug name for 10 to Texture Buffer
    Set debug name for 8 to Texture Buffer Memory
    glint::VkUtils::transitionImageLayout {
    }
    glint::Texture::generateMipmaps {
      vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier)
    }
  }
}
glint::Renderer::createPipeline {
  glint::Pipeline::Pipeline {
    glint::Pipeline::createGraphicsPipeline {
      Loading shaders, can either load pre-compiled shaders, or compile at runtime to SPIR-V
      glint::Pipeline::readFile {
        Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders/basic_tex.vert.spv fileSize: 1840 bytes
      }
      glint::Pipeline::readFile {
        Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders/basic_tex.frag.spv fileSize: 900 bytes
      }
      VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
      glint::Pipeline::createShaderModule {
      }
      VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
      glint::Pipeline::createShaderModule {
      }
      Vertex Input
      VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
      glint::Vertex::getBindingDescription {
      }
      glint::Vertex::getAttributeDescriptions {
      }
      Input Assembly
      VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
      Dynamic States - used for viewport and scissor
      Viewport State, dynamic states are used for viewport and scissor
      VkPipelineViewportStateCreateInfo viewportState{}
      Rasterizer
      VkPipelineRasterizationStateCreateInfo rasterizer{}
      rasterizer.polygonMode = VK_POLYGON_MODE_FILL
      rasterizer.lineWidth = 1.0f
      rasterizer.depthBiasEnable = VK_FALSE
      Multisampling, disabled for now.
      VkPipelineMultisampleStateCreateInfo multisampling{}
      Depth and Stencil testing, disabled for now, will pass on nullptr
      VkPipelineDepthStencilStateCreateInfo depthStencil{}
      Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
      It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
      VkPipelineColorBlendAttachmentState colorBlendAttachment{}
      Global color blending settings
      VkPipelineColorBlendStateCreateInfo colorBlending{}
      Pipeline Layout
      uniform values, push constants, etc.
      VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
      Including descriptor set layout in pipeline layout
      vkCreatePipelineLayout(m_Context->getDevice(), &pipelineLayoutInfo, nullptr, &m_PipelineLayout)
      Create Graphics Pipeline
      Graphics Pipeline, the final pipeline object that will be used in rendering
      Here we are combining : shaders, fixed function stages(vertex info, input assembly, viewport syate, rasterizer, multisampleing, depthStencil and color blending), pipeline layout and render pass
      VkGraphicsPipelineCreateInfo pipelineInfo{}
      vkCreateGraphicsPipelines(m_Context->getDevice(), VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline)
      Cleanup shader modules
      vkDestroyShaderModule(m_Context->getDevice(), fragShaderModule, nullptr)
      vkDestroyShaderModule(m_Context->getDevice(), vertShaderModule, nullptr)
    }
  }
}
glint::DescriptorPool::DescriptorPool {
  Created descriptor pool with capacity for 2 descriptor sets with multiple types
    Type: 6 Count: 2
    Type: 1 Count: 2
}
glint::UniformBuffer::UniformBuffer {
  Created uniform buffer of size 192 bytes
}
glint::UniformBuffer::UniformBuffer {
  Created uniform buffer of size 192 bytes
}
glint::Descriptor::Descriptor {
  Allocated 2 descriptor sets
}
glint::Descriptor::updateUniformBuffer {
}
glint::Descriptor::updateTextureSampler {
}
glint::MeshFactory::createTexturedCube {
  glint::Mesh::Mesh {
    glint::Mesh::createVertexBuffer {
      glint::Mesh::copyBuffer {
      }
    }
    glint::Mesh::createIndexBuffer {
      glint::Mesh::copyBuffer {
      }
    }
    Mesh created with 24 vertices and 36 indices
  }
}
glint::UniformBuffer::update {
}
glint::Renderer::drawFrame {
  --------------------------------------------------------------
  Outline of a frame..
  Wait for the previous frame to be finished
  Acquire an image from the swap chain
  Record a command buffer which draws the scene onto the image.
  Submit the command buffer to the graphics queue.
  Present the image to the swap chain for presentation.
  --------------------------------------------------------------
  glint::SynchronizationManager::waitForFence {
    Wait for the previous frame to be finished
  }
  glint::CommandManager::resetCommandBuffer {
  }
  glint::CommandManager::beginSingleTimeCommands {
  }
  glint::RenderPass::begin {
    Start Render Pass
    vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE)
  }
  glint::Pipeline::bind {
    Bind Pipeline
    vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_Pipeline)
  }
  glint::Descriptor::bind {
  }
  glint::Mesh::bind {
  }
  glint::Mesh::draw {
  }
  glint::RenderPass::end {
    End Render Pass
    vkCmdEndRenderPass(commandBuffer)
  }
  glint::CommandManager::endSingleTimeCommands {
  }
  glint::SynchronizationManager::resetFence {
  }
  result = vkQueuePresentKHR(m_Context->getPresentQueue(), &presentInfo)
}
Window resized:  2560 x 1369
glint::SwapChain::recreateSwapchain {
  vkDeviceWaitIdle(device)
  glint::SwapChain::cleanup {
    Destroying MSAA resources
    glint::SwapChain::cleanupDepthResources {
    }
    Destroying  3  framebuffers
    Destroying  3  image views
    vkDestroySwapchainKHR(device, m_SwapChain, nullptr)
  }
  glint::SwapChain::createSwapChain {
    glint::SwapChain::querySwapChainSupport {
    }
    glint::SwapChain::chooseSwapSurfaceFormat {
    }
    glint::SwapChain::chooseSwapPresentMode {
      Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
    }
    glint::SwapChain::chooseSwapExtent {
    }
    graphics and present queues are the same
    Using exclusive sharing mode
  }
  glint::SwapChain::createImageViews {
  }
  glint::SwapChain::createDepthResources {
    Set debug name for 10 to Depth Image
    Set debug name for 8 to Depth Image Memory
    Set debug name for 14 to Depth Image View
    glint::VkUtils::transitionImageLayout {
    }
  }
  glint::SwapChain::createFramebuffers {
  }
}
glint::Renderer::waitIdle {
}
glint::UniformBuffer::~UniformBuffer {
}
glint::UniformBuffer::~UniformBuffer {
}
glint::Descriptor::~Descriptor {
}
glint::DescriptorPool::~DescriptorPool {
}
glint::DescriptorSetLayout::~DescriptorSetLayout {
}
glint::Texture::~Texture {
}
glint::Mesh::~Mesh {
  vkDestroyBuffer(device, m_VertexBuffer, nullptr)
  vkFreeMemory(device, m_VertexBufferMemory, nullptr)
  vkDestroyBuffer(device, m_IndexBuffer, nullptr)
  vkFreeMemory(device, m_IndexBufferMemory, nullptr)
}
glint::Renderer::~Renderer {
}
glint::SynchronizationManager::~SynchronizationManager {
}
glint::CommandManager::~CommandManager {
}
glint::Pipeline::~Pipeline {
  vkDestroyPipeline(device, m_Pipeline, nullptr)
  vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr)
}
glint::RenderPass::~RenderPass {
  vkDestroyRenderPass(m_Context->getDevice(), m_RenderPass, nullptr)
}
glint::SwapChain::~SwapChain {
  glint::SwapChain::cleanup {
    Destroying MSAA resources
    glint::SwapChain::cleanupDepthResources {
    }
    Destroying  3  framebuffers
    Destroying  3  image views
    vkDestroySwapchainKHR(device, m_SwapChain, nullptr)
  }
}
glint::VkContext::~VkContext {
  glint::VkContext::cleanup {
    glint::DestroyDebugUtilsMessengerEXT {
    }
  }
}
glint::Window::~Window {
  glint::Window::shutdown {
    glfwDestroyWindow(m_Window)
    glfwTerminate()
  }
}
