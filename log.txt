Glint Sample Browser!
App::initWindow {
  Creating window:  800 x 600  -  Glint - Samples
  glfwCreateWindow
}
App::initRenderer {
  glint::Renderer::Renderer {
  }
  glint::Renderer::init {
    glint::VkContext::VkContext {
    }
    glint::VkContext::init {
      glint::VkContext::createInstance {
        glint::VkContext::checkValidationLayerSupport {
          found validation layer:  VK_LAYER_KHRONOS_validation
        }
        glint::VkContext::getRequiredExtensions {
          Required Extensions:  3
             VK_KHR_surface
             VK_KHR_win32_surface
             VK_EXT_debug_utils
        }
        validation layers are enabled
        glint::VkContext::populateDebugMessengerCreateInfo {
        }
        vkCreateInstance(&createInfo, nullptr, &m_Instance)
      }
      glint::VkContext::setupDebugMessenger {
        glint::VkContext::populateDebugMessengerCreateInfo {
        }
        glint::CreateDebugUtilsMessengerEXT {
        }
      }
      glint::VkContext::createSurface {
        glint::Window::createSurface {
          VkResult result = glfwCreateWindowSurface(instance, m_Window, nullptr, &surface)
        }
      }
      glint::VkContext::pickPhysicalDevice {
        Available Devices:  2
        glint::VkContext::isDeviceSuitable {
          glint::VkContext::findQueueFamilies {
          }
          glint::VkContext::checkDeviceExtensionSupport {
          }
        }
        found suitable device  NVIDIA GeForce RTX 3060 Laptop GPU
        Max Usable Sample Count:  8
      }
      glint::VkContext::createLogicalDevice {
        glint::VkContext::findQueueFamilies {
        }
        vkCreateDevice(m_PhysicalDevice, &createInfo, nullptr, &m_Device)
      }
    }
    glint::CommandManager::CommandManager {
      glint::CommandManager::createCommandPool {
        Choose graphics family as we are using the command buffer for rendering
      }
      glint::CommandManager::createCommandBuffers {
        Creating 2 command buffers
      }
    }
    glint::SwapChain::SwapChain {
      glint::SwapChain::createSwapChain {
        glint::SwapChain::querySwapChainSupport {
        }
        glint::SwapChain::chooseSwapSurfaceFormat {
        }
        glint::SwapChain::chooseSwapPresentMode {
          Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
        }
        glint::SwapChain::chooseSwapExtent {
        }
        graphics and present queues are the same
        Using exclusive sharing mode
      }
      glint::SwapChain::createImageViews {
      }
      glint::SwapChain::createDepthResources {
        Set debug name for 10 to Depth Image
        Set debug name for 8 to Depth Image Memory
        Set debug name for 14 to Depth Image View
        glint::VkUtils::transitionImageLayout {
        }
      }
    }
    glint::RenderPass::RenderPass {
      glint::RenderPass::createRenderPass {
        vkCreateRenderPass(m_Context->getDevice(), &renderPassInfo, nullptr, &m_RenderPass)
      }
    }
    glint::SwapChain::createFramebuffers {
    }
    glint::SynchronizationManager::SynchronizationManager {
      glint::SynchronizationManager::createSyncObjects {
        Synchronization:
        Semaphors: signal and wait for the image available and render finished, sync between queues
        Fences: wait for the frame to finish before starting the next one, sync between CPU and GPU
        Creating 2 sets of synchronization objects
        Create fence in signaled state, so that the first frame can start immediately
      }
    }
    Renderer initialized with 2 frames in flight and 3 swap chain images
  }
}
App::initImgui {
  glint::ImGuiManager::init {
  }
}
App::initSamples {
  glint::SampleManager::init {
  }
  glint::SampleManager::registerSample {
    Registering sample: Triangle Sample
    glint::Renderer::waitIdle {
    }
    Active sample set to: Triangle Sample
    glint::BasicSample::init {
      glint::Renderer::createPipeline {
        glint::Pipeline::Pipeline {
          glint::Pipeline::createGraphicsPipeline {
            Loading shaders, can either load pre-compiled shaders, or compile at runtime to SPIR-V
            glint::Pipeline::readFile {
              Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders\basic.vert.spv fileSize: 1052 bytes
            }
            glint::Pipeline::readFile {
              Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders\shader.frag.spv fileSize: 572 bytes
            }
            VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
            glint::Pipeline::createShaderModule {
            }
            VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
            glint::Pipeline::createShaderModule {
            }
            Vertex Input
            VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
            glint::Vertex::getBindingDescription {
            }
            glint::Vertex::getAttributeDescriptions {
            }
            Input Assembly
            VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
            Dynamic States - used for viewport and scissor
            Viewport State, dynamic states are used for viewport and scissor
            VkPipelineViewportStateCreateInfo viewportState{}
            Rasterizer
            VkPipelineRasterizationStateCreateInfo rasterizer{}
            rasterizer.polygonMode = VK_POLYGON_MODE_FILL
            rasterizer.lineWidth = 1.0f
            rasterizer.depthBiasEnable = VK_FALSE
            Multisampling, disabled for now.
            VkPipelineMultisampleStateCreateInfo multisampling{}
            Depth and Stencil testing, disabled for now, will pass on nullptr
            VkPipelineDepthStencilStateCreateInfo depthStencil{}
            Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
            It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
            VkPipelineColorBlendAttachmentState colorBlendAttachment{}
            Global color blending settings
            VkPipelineColorBlendStateCreateInfo colorBlending{}
            Pipeline Layout
            uniform values, push constants, etc.
            VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
            No descriptor set layout for pipeline layout
            vkCreatePipelineLayout(m_Context->getDevice(), &pipelineLayoutInfo, nullptr, &m_PipelineLayout)
            vkCreateGraphicsPipelines(m_Context->getDevice(), VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline)
            Cleanup shader modules
            vkDestroyShaderModule(m_Context->getDevice(), fragShaderModule, nullptr)
            vkDestroyShaderModule(m_Context->getDevice(), vertShaderModule, nullptr)
          }
        }
      }
      glint::MeshFactory::createTriangle {
        glint::Mesh::Mesh {
          glint::Mesh::createVertexBuffer {
            glint::Mesh::copyBuffer {
            }
          }
          glint::Mesh::createIndexBuffer {
            glint::Mesh::copyBuffer {
            }
          }
          Mesh created with 3 vertices and 3 indices
        }
      }
    }
  }
  glint::SampleManager::registerSample {
    Registering sample: Quad Sample
  }
  glint::RotatingSample::RotatingSample {
  }
  glint::SampleManager::registerSample {
    Registering sample: RotatingSample
  }
  glint::TexturedRotatingSample::TexturedRotatingSample {
  }
  glint::SampleManager::registerSample {
    Registering sample: TexturedRotatingSample
  }
  glint::CubeSample::CubeSample {
  }
  glint::SampleManager::registerSample {
    Registering sample: CubeSample
  }
  glint::Renderer::waitIdle {
  }
  Active sample set to: CubeSample
  glint::CubeSample::init {
    Creating resources for 2 frames in flight
    glint::MeshFactory::createTexturedCube {
      glint::Mesh::Mesh {
        glint::Mesh::createVertexBuffer {
          glint::Mesh::copyBuffer {
          }
        }
        glint::Mesh::createIndexBuffer {
          glint::Mesh::copyBuffer {
          }
        }
        Mesh created with 24 vertices and 36 indices
      }
    }
    glint::Texture::Texture {
      glint::Texture::createTextureImage {
        Loading texture from E:/tree/graphics/Glint_vk/res\texture.jpg
        Texture loaded: 512 x 512 pixels, 3 channels
        Set debug name for 9 to Texture Staging Buffer
        Set debug name for 8 to Texture Staging Buffer Memory
        Set debug name for 10 to Texture Buffer
        Set debug name for 8 to Texture Buffer Memory
        glint::VkUtils::transitionImageLayout {
        }
        glint::Texture::generateMipmaps {
          vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &barrier)
        }
      }
    }
    glint::Renderer::createPipeline {
      glint::Pipeline::~Pipeline {
        vkDestroyPipeline(device, m_Pipeline, nullptr)
        vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr)
      }
      glint::Pipeline::Pipeline {
        glint::Pipeline::createGraphicsPipeline {
          Loading shaders, can either load pre-compiled shaders, or compile at runtime to SPIR-V
          glint::Pipeline::readFile {
            Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders\basic_tex.vert.spv fileSize: 1840 bytes
          }
          glint::Pipeline::readFile {
            Loading filename: E:/tree/graphics/Glint_vk/build/bin/shaders\basic_tex.frag.spv fileSize: 900 bytes
          }
          VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
          glint::Pipeline::createShaderModule {
          }
          VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
          glint::Pipeline::createShaderModule {
          }
          Vertex Input
          VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
          glint::Vertex::getBindingDescription {
          }
          glint::Vertex::getAttributeDescriptions {
          }
          Input Assembly
          VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
          Dynamic States - used for viewport and scissor
          Viewport State, dynamic states are used for viewport and scissor
          VkPipelineViewportStateCreateInfo viewportState{}
          Rasterizer
          VkPipelineRasterizationStateCreateInfo rasterizer{}
          rasterizer.polygonMode = VK_POLYGON_MODE_FILL
          rasterizer.lineWidth = 1.0f
          rasterizer.depthBiasEnable = VK_FALSE
          Multisampling, disabled for now.
          VkPipelineMultisampleStateCreateInfo multisampling{}
          Depth and Stencil testing, disabled for now, will pass on nullptr
          VkPipelineDepthStencilStateCreateInfo depthStencil{}
          Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
          It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
          VkPipelineColorBlendAttachmentState colorBlendAttachment{}
          Global color blending settings
          VkPipelineColorBlendStateCreateInfo colorBlending{}
          Pipeline Layout
          uniform values, push constants, etc.
          VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
          Including descriptor set layout in pipeline layout
          vkCreatePipelineLayout(m_Context->getDevice(), &pipelineLayoutInfo, nullptr, &m_PipelineLayout)
          vkCreateGraphicsPipelines(m_Context->getDevice(), VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline)
          Cleanup shader modules
          vkDestroyShaderModule(m_Context->getDevice(), fragShaderModule, nullptr)
          vkDestroyShaderModule(m_Context->getDevice(), vertShaderModule, nullptr)
        }
      }
    }
    glint::DescriptorPool::DescriptorPool {
      Created descriptor pool with capacity for 2 descriptor sets with multiple types
        Type: 6 Count: 2
        Type: 1 Count: 2
    }
    glint::UniformBuffer::UniformBuffer {
      Created uniform buffer of size 192 bytes
    }
    glint::UniformBuffer::UniformBuffer {
      Created uniform buffer of size 192 bytes
    }
    glint::Descriptor::Descriptor {
      Allocated 2 descriptor sets
    }
    glint::Descriptor::updateUniformBuffer {
    }
    glint::Descriptor::updateTextureSampler {
    }
  }
}
App::mainLoop {
  glint::UniformBuffer::update {
  }
  glint::Renderer::drawFrame {
    --------------------------------------------------------------
    Outline of a frame..
    Wait for the previous frame to be finished
    Acquire an image from the swap chain
    Record a command buffer which draws the scene onto the image.
    Submit the command buffer to the graphics queue.
    Present the image to the swap chain for presentation.
    --------------------------------------------------------------
    glint::SynchronizationManager::waitForFence {
      Wait for the previous frame to be finished
    }
    glint::CommandManager::resetCommandBuffer {
    }
    glint::CommandManager::beginSingleTimeCommands {
    }
    glint::RenderPass::begin {
      Start Render Pass
      vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE)
    }
    glint::Pipeline::bind {
      Bind Pipeline
      vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_Pipeline)
    }
    glint::Descriptor::bind {
    }
    glint::Mesh::bind {
    }
    glint::Mesh::draw {
    }
    glint::RenderPass::end {
      End Render Pass
      vkCmdEndRenderPass(commandBuffer)
    }
    glint::CommandManager::endSingleTimeCommands {
    }
    glint::SynchronizationManager::resetFence {
    }
    result = vkQueuePresentKHR(m_Context->getPresentQueue(), &presentInfo)
  }
  glint::Renderer::waitIdle {
  }
}
App::cleanup {
}
glint::Mesh::~Mesh {
  vkDestroyBuffer(device, m_VertexBuffer, nullptr)
  vkFreeMemory(device, m_VertexBufferMemory, nullptr)
  vkDestroyBuffer(device, m_IndexBuffer, nullptr)
  vkFreeMemory(device, m_IndexBufferMemory, nullptr)
}
glint::UniformBuffer::~UniformBuffer {
}
glint::UniformBuffer::~UniformBuffer {
}
glint::Descriptor::~Descriptor {
}
glint::DescriptorPool::~DescriptorPool {
}
glint::DescriptorSetLayout::~DescriptorSetLayout {
}
glint::Texture::~Texture {
}
glint::Mesh::~Mesh {
  vkDestroyBuffer(device, m_VertexBuffer, nullptr)
  vkFreeMemory(device, m_VertexBufferMemory, nullptr)
  vkDestroyBuffer(device, m_IndexBuffer, nullptr)
  vkFreeMemory(device, m_IndexBufferMemory, nullptr)
}
glint::ImGuiManager::cleanup {
}
glint::Renderer::~Renderer {
}
glint::SynchronizationManager::~SynchronizationManager {
}
glint::CommandManager::~CommandManager {
}
glint::Pipeline::~Pipeline {
  vkDestroyPipeline(device, m_Pipeline, nullptr)
  vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr)
}
glint::RenderPass::~RenderPass {
  vkDestroyRenderPass(m_Context->getDevice(), m_RenderPass, nullptr)
}
glint::SwapChain::~SwapChain {
  glint::SwapChain::cleanup {
    Destroying MSAA resources
    glint::SwapChain::cleanupDepthResources {
    }
    Destroying  3  framebuffers
    Destroying  3  image views
    vkDestroySwapchainKHR(device, m_SwapChain, nullptr)
  }
}
glint::VkContext::~VkContext {
  glint::VkContext::cleanup {
    glint::DestroyDebugUtilsMessengerEXT {
    }
  }
}
glint::Window::~Window {
  glint::Window::shutdown {
    glfwDestroyWindow(m_Window)
    glfwTerminate()
  }
}
