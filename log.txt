Illiterate Vulkan!
App::initWindow {
  Creating window:  800 x 600  -  Vulkan
  glfwCreateWindow
}
App::initVulkan {
  glint::VulkanContext::VulkanContext {
  }
  glint::VulkanContext::init {
    glint::VulkanContext::createInstance {
      glint::VulkanContext::checkValidationLayerSupport {
        found validation layer:  VK_LAYER_KHRONOS_validation
      }
      glint::VulkanContext::getRequiredExtensions {
        Required Extensions:  3
           VK_KHR_surface
           VK_KHR_win32_surface
           VK_EXT_debug_utils
      }
      validation layers are enabled
      glint::VulkanContext::populateDebugMessengerCreateInfo {
      }
      vkCreateInstance(&createInfo, nullptr, &m_Instance)
    }
    glint::VulkanContext::setupDebugMessenger {
      glint::VulkanContext::populateDebugMessengerCreateInfo {
      }
      glint::CreateDebugUtilsMessengerEXT {
      }
    }
    glint::VulkanContext::createSurface {
      glint::Window::createSurface {
        VkResult result = glfwCreateWindowSurface(instance, m_Window, nullptr, &surface)
      }
    }
    glint::VulkanContext::pickPhysicalDevice {
      Available Devices:  2
      glint::VulkanContext::isDeviceSuitable {
        glint::VulkanContext::findQueueFamilies {
        }
        glint::VulkanContext::checkDeviceExtensionSupport {
        }
      }
      found suitable device  NVIDIA GeForce RTX 3060 Laptop GPU
    }
    glint::VulkanContext::createLogicalDevice {
      glint::VulkanContext::findQueueFamilies {
      }
      vkCreateDevice(m_PhysicalDevice, &createInfo, nullptr, &m_Device)
    }
  }
  glint::SwapChain::SwapChain {
    glint::SwapChain::createSwapChain {
      glint::SwapChain::querySwapChainSupport {
      }
      glint::SwapChain::chooseSwapSurfaceFormat {
      }
      glint::SwapChain::chooseSwapPresentMode {
        Using VK_PRESENT_MODE_MAILBOX_KHR (triple buffering)
      }
      glint::SwapChain::chooseSwapExtent {
      }
      graphics and present queues are the same
      Using exclusive sharing mode
    }
    glint::SwapChain::createImageViews {
    }
  }
  glint::RenderPass::RenderPass {
    glint::RenderPass::createRenderPass {
      clear the values to a constant at the start
      colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR
      store the values to memory for reading later
      colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE
      not using stencil buffer
      colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE
      colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE
      layout transition before and after render pass
      colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
      colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
      which attachment to reference by its index in the attachment descriptions array
      colorAttachmentRef.attachment = 0
      layout the attachment will have during a subpass
      colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
      subpass dependencies, for layout transitions
      subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS
      subpass.colorAttachmentCount = 1
      subpass.pColorAttachments = &colorAttachmentRef
      dependency between the subpass and the external render pass
      dependency.srcSubpass = VK_SUBPASS_EXTERNAL
      dependency.dstSubpass = 0
      dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
      dependency.srcAccessMask = 0
      dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
      dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
      Render Pass
      VkRenderPassCreateInfo renderPassInfo{}
      vkCreateRenderPass(m_Context->getDevice(), &renderPassInfo, nullptr, &m_RenderPass)
    }
  }
  glint::Pipeline::Pipeline {
    glint::Pipeline::createGraphicsPipeline {
      Loading shaders, can either load pre-compiled shaders, or compile at runtime to SPIR-V
      glint::Pipeline::readFile {
        Loading filename: ./bin/shaders/shader.vert.spv fileSize: 1504 bytes
      }
      glint::Pipeline::readFile {
        Loading filename: ./bin/shaders/shader.frag.spv fileSize: 572 bytes
      }
      VkShaderModule vertShaderModule = createShaderModule(vertShaderCode)
      glint::Pipeline::createShaderModule {
      }
      VkShaderModule fragShaderModule = createShaderModule(fragShaderCode)
      glint::Pipeline::createShaderModule {
      }
      Vertex Input
      VkPipelineVertexInputStateCreateInfo vertexInputInfo{}
      Input Assembly
      VkPipelineInputAssemblyStateCreateInfo inputAssembly{}
      Dynamic States - used for viewport and scissor
      Viewport State, dynamic states are used for viewport and scissor
      VkPipelineViewportStateCreateInfo viewportState{}
      Rasterizer
      VkPipelineRasterizationStateCreateInfo rasterizer{}
      Using anything else requires enabling GPU features.
      rasterizer.polygonMode = VK_POLYGON_MODE_FILL
      rasterizer.lineWidth = 1.0f
      rasterizer.depthBiasEnable = VK_FALSE
      Depth Bias, for shadow mapping.
      Multisampling, disabled for now.
      VkPipelineMultisampleStateCreateInfo multisampling{}
      Depth and Stencil testing, disabled for now, will pass on nullptr
      Color Blending, finalColor = newColor * newAlpha <colorBlendOp> oldColor * (1 - newAlpha)
      It is possible to have multiple color blending attachments, have logical ops, and have separate blending for each color channel.
      VkPipelineColorBlendAttachmentState colorBlendAttachment{}
      Global color blending settings
      VkPipelineColorBlendStateCreateInfo colorBlending{}
      Pipeline Layout
      uniform values, push constants, etc.
      VkPipelineLayoutCreateInfo pipelineLayoutInfo{}
      vkCreatePipelineLayout(m_Context->getDevice(), &pipelineLayoutInfo, nullptr, &m_PipelineLayout)
      Create Graphics Pipeline
      Graphics Pipeline, the final pipeline object that will be used in rendering
      Here we are combining : shaders, fixed function stages(vertex info, input assembly, viewport syate, rasterizer, multisampleing, depthStencil and color blending), pipeline layout and render pass
      VkGraphicsPipelineCreateInfo pipelineInfo{}
      vkCreateGraphicsPipelines(m_Context->getDevice(), VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline)
      Cleanup shader modules
      vkDestroyShaderModule(m_Context->getDevice(), fragShaderModule, nullptr)
      vkDestroyShaderModule(m_Context->getDevice(), vertShaderModule, nullptr)
    }
  }
  glint::SwapChain::createFramebuffers {
  }
  App::createCommandPool {
    VkCommandPoolCreateInfo poolInfo{}
    Choose graphics family as we are using the command buffer for rendering
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value()
    vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool)
  }
  App::createCommandBuffer {
    VkCommandBufferAllocateInfo allocInfo{}
    vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer)
  }
  App::createSyncObjects {
    Synchronization:
    Semaphors: signal and wait for the image available and render finished, sync between queues
    Fences: wait for the frame to finish before starting the next one, sync between CPU and GPU
    Create fence in signaled state, so that the first frame can start immediately
    vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphore)
    vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphore)
    vkCreateFence(device, &fenceInfo, nullptr, &inFlightFence)
  }
}
App::mainLoop {
  while (!window->shouldClose())
  App::drawFrame {
    --------------------------------------------------------------
    Outline of a frame..
    Wait for the previous frame to be finished
    Acquire an image from the swap chain
    Record a command buffer which draws the scene onto the image.
    Submit the command buffer to the graphics queue.
    Present the image to the swap chain for presentation.
    --------------------------------------------------------------
    Wait for the previous frame to be finished
    vkWaitForFences(device, 1, &inFlightFence, VK_TRUE, UINT64_MAX)
    vkResetFences(device, 1, &inFlightFence)
    Acquire an image from the swap chain
    vkAcquireNextImageKHR(device, swapChain->getSwapChain(), UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex)
    vkResetCommandBuffer(commandBuffer, 0)
    Record a command buffer which draws the scene onto the image.
    App::recordCommandBuffer {
      vkBeginCommandBuffer(commandBuffer, &beginInfo)
      glint::RenderPass::begin {
        Start Render Pass
        VkRenderPassBeginInfo renderPassInfo{}
        vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE)
      }
      Bind Pipeline
      vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline->getPipeline())
      Set dynamic states
      vkCmdSetViewport(commandBuffer, 0, 1, &viewport)
      vkCmdSetScissor(commandBuffer, 0, 1, &scissor)
      FINALLY DRAW!!!
      vkCmdDraw(commandBuffer, 3, 1, 0, 0)
      glint::RenderPass::end {
        End Render Pass
        vkCmdEndRenderPass(commandBuffer)
      }
      vkEndCommandBuffer(commandBuffer)
      Command Buffer Recorded
    }
    Wait for the imageAvailableSemaphore..
    Wait till the color attachment is ready for writing..
    Submit the command buffer to the graphics queue
    vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFence)
    Presentation
    Wait for the renderFinishedSemaphore..
    Specify swap chain to present to.
    Present the image to the swap chain for presentation.
    vkQueuePresentKHR(presentQueue, &presentInfo)
  }
  vkDeviceWaitIdle(device)
}
App::cleanup {
  vkDestroySemaphore(device, renderFinishedSemaphore, nullptr)
  vkDestroySemaphore(device, imageAvailableSemaphore, nullptr)
  vkDestroyFence(device, inFlightFence, nullptr)
  vkDestroyCommandPool(device, commandPool, nullptr)
  glint::Pipeline::~Pipeline {
    vkDestroyPipeline(device, m_Pipeline, nullptr)
    vkDestroyPipelineLayout(device, m_PipelineLayout, nullptr)
  }
  glint::RenderPass::~RenderPass {
    vkDestroyRenderPass(m_Context->getDevice(), m_RenderPass, nullptr)
  }
  glint::SwapChain::~SwapChain {
    Destroying  3  framebuffers
    Destroying  3  image views
    vkDestroySwapchainKHR(device, m_SwapChain, nullptr)
  }
  glint::VulkanContext::~VulkanContext {
    glint::VulkanContext::cleanup {
      glint::DestroyDebugUtilsMessengerEXT {
      }
    }
  }
  glint::Window::~Window {
    glint::Window::shutdown {
      glfwDestroyWindow(m_Window)
      glfwTerminate()
    }
  }
}
